From 91bec1167d66789facc8184963630af298e68fb0 Mon Sep 17 00:00:00 2001
From: CastagnaIT <gottardo.stefano.83@gmail.com>
Date: Mon, 28 Aug 2023 18:07:23 +0200
Subject: [PATCH] test4

---
 src/common/AdaptiveStream.cpp |  4 ++++
 src/common/AdaptiveTree.cpp   | 11 +++++++++++
 src/common/AdaptiveTree.h     |  5 +++++
 3 files changed, 20 insertions(+)

diff --git a/src/common/AdaptiveStream.cpp b/src/common/AdaptiveStream.cpp
index 6d5f3112b..b5cfb0756 100644
--- a/src/common/AdaptiveStream.cpp
+++ b/src/common/AdaptiveStream.cpp
@@ -814,6 +814,10 @@ bool AdaptiveStream::ensureSegment()
   {
     // wait until worker is ready for new segment
     std::unique_lock<std::mutex> lck(thread_data_->mutex_dl_);
+
+    if (state_ == STOPPED)
+      return false;
+
     // lock live segment updates
     std::lock_guard<adaptive::AdaptiveTree::TreeUpdateThread> lckUpdTree(tree_.GetTreeUpdMutex());
 
diff --git a/src/common/AdaptiveTree.cpp b/src/common/AdaptiveTree.cpp
index 04e6bdf21..b5cee5ff5 100644
--- a/src/common/AdaptiveTree.cpp
+++ b/src/common/AdaptiveTree.cpp
@@ -572,6 +572,8 @@ namespace adaptive
         // If paused, wait until last "Resume" will be called
         std::unique_lock<std::mutex> lckWait(m_waitMutex);
         m_cvWait.wait(lckWait, [&] { return m_waitQueue == 0; });
+        if (m_threadStop)
+          break;
 
         updLck.lock();
         m_tree->RefreshLiveSegments();
@@ -579,6 +581,15 @@ namespace adaptive
     }
   }
 
+  void AdaptiveTree::TreeUpdateThread::Stop()
+  {
+    m_threadStop = true;
+    // If an update is already in progress wait until exit
+    std::lock_guard<std::mutex> updLck{m_updMutex};
+    m_cvUpdInterval.notify_all();
+    m_cvWait.notify_all();
+  }
+
   void AdaptiveTree::TreeUpdateThread::Pause()
   {
     // If an update is already in progress the wait until its finished
diff --git a/src/common/AdaptiveTree.h b/src/common/AdaptiveTree.h
index 45ef4044d..3d905ee55 100644
--- a/src/common/AdaptiveTree.h
+++ b/src/common/AdaptiveTree.h
@@ -525,6 +525,8 @@ class ATTR_DLL_LOCAL AdaptiveTree
   AdaptiveTree(const AdaptiveTree& left);
   virtual ~AdaptiveTree()
   {
+    m_updThread.Stop();
+
     for (auto period : periods_)
       delete period;
   }
@@ -639,6 +641,9 @@ class ATTR_DLL_LOCAL AdaptiveTree
     // \brief As "std::mutex" unlock, but resume the manifest updates (support std::lock_guard).
     void unlock() { Resume(); }
 
+    // \brief Stop performing new updates.
+    void Stop();
+
   private:
     void Worker();
     void Pause();
